third <- Q[3] * (P[3] - P[2])
first * second - third
P <- c(12.64,12.42,17.15)
Q <- c(3.44,4.11,5.19)
p <- log(P)
q <- log(Q)
t <- c(1989,1990,1994)
#Solve for solution to e
num <- (t[2]-t[1]) * (q[3] - q[1]) - (t[3]-t[1]) * (q[2] - q[1])
den <- (t[2]-t[1]) * (p[3] - p[1]) - (t[3]-t[1]) * (p[2] - p[1])
e <- num / den
print(e)
#Check answer:
b <- (q[2] - q[1] - e * (p[2]-p[1])) / (t[2] - t[1])
a <- q[1] - b * t[1] - e * p[1]
#This gives the vector Q as desired
exp(a + b * t) * P^e
#Derivative Q'(P_3)
Qp <- exp(a + b * t[3]) * e * P[3]^(e-1)
#Marginal cost from monopoly model
C <- P[3] + Q[3] / Qp
print(C)
Qf <- function(x,t){
exp(a + b * t) * x^e
}
#Loss in profits
loss <- Q[3] * (P[3] - C) - Qf(P[2],t[3]) * (P[2] - C)
#Consumer surplus
#Qf(P[2],1994) - Qf(P[3],1994)
first <- exp(a + b * t[3]) / (e + 1)
second <- (P[3]^(e + 1) - P[2]^(e + 1))
third <- Q[3] * (P[3] - P[2])
first * second - third
#Q15
Q <- c(4.11,5.19)
P <- c(12.42,17.15)
F <- c(0.53,1.66)
t <- c(1990,1994)
#Solve for elasticity
phi <- log(F[2]/F[1]) / log(P[2]/P[1])
#Back out intercept
F0 <- (F / P^phi)[1]
#Derivatives
Qp <- exp(a + b * t) * e * P^(e - 1)
Fp <- F0 * phi * P^phi
#FOC:
C <- P[2] + (Q[2] - F[2]) / (Qp[2] - Fp[2])
#Functions
Qf <- function(P, t){
exp(a + b * t) + P^e
}
Ff <- function(P){
F0 * P^phi
}
#Counterfactual:
current <- (Qf(P[2],t[2]) - Ff(P[2])) * (P[2] - C)
counterf <- (Qf(P[1],t[2]) - Ff(P[1])) * (P[1] - C)
current - counterf
F[2] * (P[2] - C)
P <- c(12.64,12.42,17.15)
Q <- c(3.44,4.11,5.19)
p <- log(P)
q <- log(Q)
t <- c(1989,1990,1994)
#Solve for solution to e
num <- (t[2]-t[1]) * (q[3] - q[1]) - (t[3]-t[1]) * (q[2] - q[1])
den <- (t[2]-t[1]) * (p[3] - p[1]) - (t[3]-t[1]) * (p[2] - p[1])
e <- num / den
print(e)
#Check answer:
b <- (q[2] - q[1] - e * (p[2]-p[1])) / (t[2] - t[1])
a <- q[1] - b * t[1] - e * p[1]
#This gives the vector Q as desired
exp(a + b * t) * P^e
#Derivative Q'(P_3)
Qp <- exp(a + b * t[3]) * e * P[3]^(e-1)
#Marginal cost from monopoly model
C <- P[3] + Q[3] / Qp
print(C)
Qf <- function(x,t){
exp(a + b * t) * x^e
}
#Loss in profits
loss <- Q[3] * (P[3] - C) - Qf(P[2],t[3]) * (P[2] - C)
#Consumer surplus
#Qf(P[2],1994) - Qf(P[3],1994)
first <- exp(a + b * t[3]) / (e + 1)
second <- (P[3]^(e + 1) - P[2]^(e + 1))
#third <- Q[3] * (P[3] - P[2])
first * second
setwd(file.path(
"~", "Dropbox-HarvardUniversity", "Martin Bernstein",
"Fall 2025", "Other", "LCC"
))
source(file.path("code", "IO-matrices", "NIPA-utility-functions.R"))
years <- 1963:2023
i <- 1
# Read data
year <- years[i]
print(paste0("Building matrix for ", year))
if (year <= 1996) {
m <- read_excel(
file.path(
"data", "NIPA",
"IO tables", "IO_1963-1996",
"IOUse_Before_Redefinitions_PRO_1963-1996_Summary.xlsx"
),
sheet = as.character(year)
)
colnames(m) <- m[5, ]
colcodes <- m[4, 3:ncol(m)]
} else {
m <- read_excel(
file.path(
"data", "NIPA", "IO tables", "IO_1997-2023",
"IOUse_Before_Redefinitions_PRO_1997-2023_Summary.xlsx"
),
sheet = as.character(year)
)
colnames(m) <- m[6, ]
colcodes <- m[5, ]
}
# Extract codes for industries (columns)
colcodes <- pivot_longer(colcodes,
cols = seq_len(ncol(colcodes)),
names_to = "industry", values_to = "ind_code")
setDT(colcodes)
colcodes <- colcodes[!is.na(ind_code)]
# Clean
m <- m[7:nrow(m), ]
setDT(m)
m
colcodes
m <- read_excel(
file.path(
"data", "NIPA",
"IO tables", "IO_1963-1996",
"IOUse_Before_Redefinitions_PRO_1963-1996_Summary.xlsx"
),
sheet = as.character(year)
)
m
colnames(m) <- m[5, ]
colcodes <- m[6, 3:ncol(m)]
colcodes
year <- years[i]
print(paste0("Building matrix for ", year))
if (year <= 1996) {
m <- read_excel(
file.path(
"data", "NIPA",
"IO tables", "IO_1963-1996",
"IOUse_Before_Redefinitions_PRO_1963-1996_Summary.xlsx"
),
sheet = as.character(year)
)
colnames(m) <- m[5, ]
colcodes <- m[6, 3:ncol(m)]
} else {
m <- read_excel(
file.path(
"data", "NIPA", "IO tables", "IO_1997-2023",
"IOUse_Before_Redefinitions_PRO_1997-2023_Summary.xlsx"
),
sheet = as.character(year)
)
colnames(m) <- m[6, ]
colcodes <- m[5, ]
}
colcodes
colcodes <- m[6,]
colcodes
# Extract codes for industries (columns)
colcodes <- pivot_longer(colcodes,
cols = seq_len(ncol(colcodes)),
names_to = "industry", values_to = "ind_code")
colcodes
colcodes <- m[6, 3:ncol(m)]
colcodes <- pivot_longer(colcodes,
cols = seq_len(ncol(colcodes)),
names_to = "industry", values_to = "ind_code")
colcodes
setDT(colcodes)
colcodes <- colcodes[!is.na(ind_code)]
colcodes
m <- m[7:nrow(m), ]
setDT(m)
m
res <- build_matrix(m, colcodes, year)
#Function to build clean IO matrix and aggregates
#CURRENTLY ONLY WORKS post 1997: need to fix this for pre 1996.
build_matrix <- function(m, colcodes, year){
#Format long
key <- m[!is.na(IOCode) & !is.na(Name), .(IOCode, Name)]
setnames(m, old = c("Name", "IOCode"), new = c("commodity", "code_commodity"))
dt <- setDT(pivot_longer(m, cols = 3:(ncol(m)-2),
names_to = "industry", values_to = "value"))
dt[, year := year]
dt[,c('Total Final Uses (GDP)','Total Commodity Output') := NULL]
#Clean, get key
dt[,code_industry := colcodes[.SD,on = .(industry), x.ind_code]]
#Remove final uses
dt <- dt[!substr(code_industry,1,1)=="F"]
convert <- c("value")
dt[,(convert) := lapply(.SD, as.numeric),.SDcols = convert]
#Industry aggregates:
totals <- dt[commodity == "Total Industry Output", .(industry, value)]
dt[, total_industry_output := totals[.SD, on = .(industry), x.value]]
aggs <- dt[commodity == 'Total Intermediate' |
code_commodity %in% c("V001", "V002", "V003")]
aggs[,code_commodity := NULL]
setnames(aggs, old = "commodity", new = "item")
aggs <- aggs[, .(code_industry, industry, item, value, total_industry_output)]
#Format
dt <- dt[!is.na(code_commodity) & !is.na(commodity)]
dt <- dt[, .(year, code_industry, industry, code_commodity, commodity,
value, total_industry_output)]
#Shares
setorder(dt,code_industry,code_commodity)
dt[is.na(value), value := 0]
dt[,share := value / total_industry_output]
#Test that sums are correct:
dt[, test := sum(value) / total_industry_output, by=.(code_industry)]
resid <- max(abs(dt$test - 1))
if(resid > 1e-3){
print(paste0("Warning: error of ", round(resid, digits = 5),
" in year ",year))
}
return(list(dt, agg))
}
res <- build_matrix(m, colcodes, year)
m
names(m)
year <- years[i]
print(paste0("Building matrix for ", year))
if (year <= 1996) {
m <- read_excel(
file.path(
"data", "NIPA",
"IO tables", "IO_1963-1996",
"IOUse_Before_Redefinitions_PRO_1963-1996_Summary.xlsx"
),
sheet = as.character(year)
)
colnames(m) <- m[5, ]
colnames(m)[1:2] <- c("IOCode", "Name")
colcodes <- m[6, 3:ncol(m)]
} else {
m <- read_excel(
file.path(
"data", "NIPA", "IO tables", "IO_1997-2023",
"IOUse_Before_Redefinitions_PRO_1997-2023_Summary.xlsx"
),
sheet = as.character(year)
)
colnames(m) <- m[6, ]
colcodes <- m[5, ]
}
# Extract codes for industries (columns)
colcodes <- pivot_longer(colcodes,
cols = seq_len(ncol(colcodes)),
names_to = "industry", values_to = "ind_code")
setDT(colcodes)
colcodes <- colcodes[!is.na(ind_code)]
# Clean
m <- m[7:nrow(m), ]
setDT(m)
# Use this to build matrix
res <- build_matrix(m, colcodes, year)
build_matrix <- function(m, colcodes, year){
#Format long
key <- m[!is.na(IOCode) & !is.na(Name), .(IOCode, Name)]
setnames(m, old = c("Name", "IOCode"), new = c("commodity", "code_commodity"))
dt <- setDT(pivot_longer(m, cols = 3:(ncol(m)-2),
names_to = "industry", values_to = "value"))
dt[, year := year]
dt[,c('Total Final Uses (GDP)','Total Commodity Output') := NULL]
#Clean, get key
dt[,code_industry := colcodes[.SD,on = .(industry), x.ind_code]]
#Remove final uses
dt <- dt[!substr(code_industry,1,1)=="F"]
convert <- c("value")
dt[,(convert) := lapply(.SD, as.numeric),.SDcols = convert]
#Industry aggregates:
totals <- dt[commodity == "Total Industry Output", .(industry, value)]
dt[, total_industry_output := totals[.SD, on = .(industry), x.value]]
aggs <- dt[commodity == 'Total Intermediate' |
code_commodity %in% c("V001", "V002", "V003")]
aggs[,code_commodity := NULL]
setnames(aggs, old = "commodity", new = "item")
aggs <- aggs[, .(code_industry, industry, item, value, total_industry_output)]
#Format
dt <- dt[!is.na(code_commodity) & !is.na(commodity)]
dt <- dt[, .(year, code_industry, industry, code_commodity, commodity,
value, total_industry_output)]
#Shares
setorder(dt,code_industry,code_commodity)
dt[is.na(value), value := 0]
dt[,share := value / total_industry_output]
#Test that sums are correct:
dt[, test := sum(value) / total_industry_output, by=.(code_industry)]
resid <- max(abs(dt$test - 1))
if(resid > 1e-3){
print(paste0("Warning: error of ", round(resid, digits = 5),
" in year ",year))
}
return(list(dt, aggs))
}
res <- build_matrix(m, colcodes, year)
year <- years[i]
print(paste0("Building matrix for ", year))
if (year <= 1996) {
m <- read_excel(
file.path(
"data", "NIPA",
"IO tables", "IO_1963-1996",
"IOUse_Before_Redefinitions_PRO_1963-1996_Summary.xlsx"
),
sheet = as.character(year)
)
colnames(m) <- m[5, ]
colnames(m)[1:2] <- c("IOCode", "Name")
colcodes <- m[6, 3:ncol(m)]
} else {
m <- read_excel(
file.path(
"data", "NIPA", "IO tables", "IO_1997-2023",
"IOUse_Before_Redefinitions_PRO_1997-2023_Summary.xlsx"
),
sheet = as.character(year)
)
colnames(m) <- m[6, ]
colcodes <- m[5, ]
}
# Extract codes for industries (columns)
colcodes <- pivot_longer(colcodes,
cols = seq_len(ncol(colcodes)),
names_to = "industry", values_to = "ind_code")
setDT(colcodes)
colcodes <- colcodes[!is.na(ind_code)]
# Clean
m <- m[7:nrow(m), ]
setDT(m)
# Use this to build matrix
res <- build_matrix(m, colcodes, year)
dt <- res[[1]]
dt
dt
# Read data
year <- years[i]
print(paste0("Building matrix for ", year))
if (year <= 1996) {
m <- read_excel(
file.path(
"data", "NIPA",
"IO tables", "IO_1963-1996",
"IOUse_Before_Redefinitions_PRO_1963-1996_Summary.xlsx"
),
sheet = as.character(year)
)
colnames(m) <- m[5, ]
colnames(m)[1:2] <- c("IOCode", "Name")
colcodes <- m[6, 3:ncol(m)]
} else {
m <- read_excel(
file.path(
"data", "NIPA", "IO tables", "IO_1997-2023",
"IOUse_Before_Redefinitions_PRO_1997-2023_Summary.xlsx"
),
sheet = as.character(year)
)
colnames(m) <- m[6, ]
colcodes <- m[5, ]
}
# Extract codes for industries (columns)
colcodes <- pivot_longer(colcodes,
cols = seq_len(ncol(colcodes)),
names_to = "industry", values_to = "ind_code")
setDT(colcodes)
colcodes <- colcodes[!is.na(ind_code)]
# Clean
m <- m[7:nrow(m), ]
setDT(m)
key <- m[!is.na(IOCode) & !is.na(Name), .(IOCode, Name)]
key
dt <- setDT(pivot_longer(m, cols = 3:(ncol(m)-2),
names_to = "industry", values_to = "value"))
dt[, year := year]
dt[,c('Total Final Uses (GDP)','Total Commodity Output') := NULL]
#Clean, get key
dt[,code_industry := colcodes[.SD,on = .(industry), x.ind_code]]
#Remove final uses
dt <- dt[!substr(code_industry,1,1)=="F"]
convert <- c("value")
dt[,(convert) := lapply(.SD, as.numeric),.SDcols = convert]
#Industry aggregates:
totals <- dt[commodity == "Total Industry Output", .(industry, value)]
year <- years[i]
print(paste0("Building matrix for ", year))
if (year <= 1996) {
m <- read_excel(
file.path(
"data", "NIPA",
"IO tables", "IO_1963-1996",
"IOUse_Before_Redefinitions_PRO_1963-1996_Summary.xlsx"
),
sheet = as.character(year)
)
colnames(m) <- m[5, ]
colnames(m)[1:2] <- c("IOCode", "Name")
colcodes <- m[6, 3:ncol(m)]
} else {
m <- read_excel(
file.path(
"data", "NIPA", "IO tables", "IO_1997-2023",
"IOUse_Before_Redefinitions_PRO_1997-2023_Summary.xlsx"
),
sheet = as.character(year)
)
colnames(m) <- m[6, ]
colcodes <- m[5, ]
}
# Extract codes for industries (columns)
colcodes <- pivot_longer(colcodes,
cols = seq_len(ncol(colcodes)),
names_to = "industry", values_to = "ind_code")
setDT(colcodes)
colcodes <- colcodes[!is.na(ind_code)]
# Clean
m <- m[7:nrow(m), ]
setDT(m)
key <- m[!is.na(IOCode) & !is.na(Name), .(IOCode, Name)]
setnames(m, old = c("Name", "IOCode"), new = c("commodity", "code_commodity"))
dt <- setDT(pivot_longer(m, cols = 3:(ncol(m)-2),
names_to = "industry", values_to = "value"))
dt[, year := year]
dt[,c('Total Final Uses (GDP)','Total Commodity Output') := NULL]
#Clean, get key
dt[,code_industry := colcodes[.SD,on = .(industry), x.ind_code]]
#Remove final uses
dt <- dt[!substr(code_industry,1,1)=="F"]
convert <- c("value")
dt[,(convert) := lapply(.SD, as.numeric),.SDcols = convert]
#Industry aggregates:
totals <- dt[commodity == "Total Industry Output", .(industry, value)]
dt[, total_industry_output := totals[.SD, on = .(industry), x.value]]
aggs <- dt[commodity == 'Total Intermediate' |
code_commodity %in% c("V001", "V002", "V003")]
aggs[,code_commodity := NULL]
setnames(aggs, old = "commodity", new = "item")
aggs <- aggs[, .(code_industry, industry, item, value, total_industry_output)]
dt <- dt[!is.na(code_commodity) & !is.na(commodity)]
dt
dt <- dt[!is.na(code_commodity) & !is.na(commodity)] #No code in post-1996
dt <- dt[!code_industry %in% c("T005", "T006", "T008")] #These are agg codes in pre-1996
dt
dt <- dt[, .(year, code_industry, industry, code_commodity, commodity,
value, total_industry_output)]
setorder(dt,code_industry,code_commodity)
dt[is.na(value), value := 0]
dt[,share := value / total_industry_output]
dt[, test := sum(value) / total_industry_output, by=.(code_industry)]
resid <- max(abs(dt$test - 1))
if(resid > 1e-3){
print(paste0("Warning: error of ", round(resid, digits = 5),
" in year ",year))
}
dt
aggs
dt
dt <- dt[!code_industry %in% c("T001", "T004", "T007")] #These are agg codes in pre-1996
dt <- dt[!code_commodity %in% c("T005", "T006", "T008")]
dt <- dt[, .(year, code_industry, industry, code_commodity, commodity,
value, total_industry_output)]
#Shares
setorder(dt,code_industry,code_commodity)
dt[is.na(value), value := 0]
dt[,share := value / total_industry_output]
#Test that sums are correct:
dt[, test := sum(value) / total_industry_output, by=.(code_industry)]
resid <- max(abs(dt$test - 1))
if(resid > 1e-3){
print(paste0("Warning: error of ", round(resid, digits = 5),
" in year ",year))
}
dt
#Airtable reading
token <- 'pat7JpuJa2gvOmUJJ.d8770b99cf65993fb14e0481c286d49d160c94f4646e410e9459a9965f9082c1'
set_airtable_api_key(token)
library(ggplot2)
library(maps)
library(data.table)
library(dplyr)
library(rairtable)
token <- 'pat7JpuJa2gvOmUJJ.d8770b99cf65993fb14e0481c286d49d160c94f4646e410e9459a9965f9082c1'
set_airtable_api_key(token)
baseid <- 'appmZrocL69psc6h8'
comst <- airtable("Committees",baseid)
comst
contt <- airtable("Contacts", baseid)
rolest <- airtable("Organizational Roles", baseid)
contt <- airtable("Contacts", baseid)
orgt <- airtable("Organizations", baseid)
roles <- read_airtable(rolest)
roles <- read_airtable(rolest)%>%
setDT()
roles
contacts <- read_airtable(contt)%>%
setDT()
orgs <- read_airtable(orgt)%>%
setDT()
orgs <- read_airtable(orgt)
